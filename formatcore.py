#!/usr/bin/env python3

"""formatcore

Usage:
  formatcore.py  [-c <configfile>] ([-p] | [-o <directory>] [-s <suffix>]) <coredumps>...
  
Arguments:
  coredumps    Coredump file(s) to process.  May be a file, directory, or wildcard

Options:
  -p                     Print output to screen
  -c <configfile>        Specify a configuration file.   [default: ./coredump.cfg]
  -o <directory>         Specifiy an output destination directory
  -s <suffix>            Specify a suffix for output files
"""

from docopt import docopt
from subprocess import Popen
import re
import os
import sys
import glob
if sys.version_info[0] > 2:
    import configparser as ConfigParser
else:
    import ConfigParser


def parse_args():
    args = {}
    # Parse CLI arguments and set defaults
    arguments = docopt(__doc__, version='Cores 0.9')

    # print (arguments)

    # The defaults for these options are set in the
    # config file.  If they exist here
    # they will be overwritten

    if arguments['-c'] is not False:
        args['config_file'] = arguments['-c']
    if arguments['-o'] is not None:
        args['output_dir'] = arguments['-o']
    if arguments['-s'] is not None:
        args['suffix'] = arguments['-s']
    if arguments['-p'] is not False:
        args['output_method'] = 'stdout'

    # Arguments
    args['coredumps'] = arguments['<coredumps>']

    return args


def parse_config(config_file):
    cfg = {}
    if not os.path.exists(config_file):
        print ("Config file not found")
        sys.exit()

    # Parse config file and set values
    config = ConfigParser.ConfigParser()
    config.read(config_file)

    cfg['search_regex'] = config.get("formating", "regex")
    cfg['working_dir'] = config.get("formating", "working_dir")
    cfg['suffix'] = config.get("formating", "suffix")
    cfg['output_dir'] = config.get("formating", "output_dir")
    cfg['output_method'] = config.get("formating", "output_method")
    cfg['objdump_command'] = config.get("formating", "objdump_command")

    return cfg


def get_coredump_list(coredump_list):
    '''
    Some systems auto expand wildcards (such as Unix) and some may not
    this function will expand a wildcard into a file_list of files (even if there's
    only one) and return it.

    Since glob always returns a file_list, we'll flatten it before returning

    '''
    final_list = []
    for coredump in coredump_list:
        file_list = (glob.glob(coredump))
        for current_file in file_list:
            if os.path.isfile(current_file) == False:
                print("Error: File '{}' does not exist".
                      format(coredump))
                sys.exit()
        final_list.append(file_list)

    # This flattens the list returned by glob
    final_list = [x for sublist in final_list for x in sublist]
    return final_list


def run_objdump(coredump, config):
    '''
    Run objdump on the files and output a temporary file in the working_dir
    for later processing
    '''

    filename = os.path.basename(coredump)
    output_filename = os.path.join(config['working_dir'], filename + ".tmp")

    # This runs the objdump command specified in the config file
    #
    output_file = config['objdump_command'] + " " + coredump + \
        " > " + output_filename
    process = Popen(output_file, shell=True)
    process.communicate()

    return output_filename


def split_objdump(coredump, search_regex):
    with open(coredump) as f:
        '''
        Parses the core f generated by objdump -s <file> and returns only the string containing
        useful information about the core

        Something like this:

        cbeicrd.1000.69100.DBPATH=/usr/cbridge/data.TERM=linux.INFORMIXDIR=/usr/informix.CBHOME= \
        /usr/cbridge.PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/sbin:/sbin:/bin.PWD=/.INFORMIXSERVER= \
        cbridge_on.SHLVL=0.GFHOME=/opt/SDK.INFORMIXSQLHOSTS=/usr/informix/etc/sqlhosts.UPSTART_INSTANCE= \
        .UPSTART_JOB=cbridge.CBDBUSER=cbclient.CBDBPASSWD=.cbr1dg3.CLIENT_LOCALE=en_US.819. \
        LD_LIBRARY_PATH=/usr/cbridge/bin:/usr/local/ssl/lib:/usr/nms/lib.AGLOAD=/opt/nms/ag/load:/opt/nms/ag/cfg. \
        CTA_DPATH=/opt/nms/ctaccess/prompts:/opt/nms/ctaccess/cfg./usr/cbridge/bin/cbeicrd
        '''

        lines = []
        for line in f:
            # Split columns into a list
            split_line = line.split(" ")
            try:
                # This probably is inefficient but it then combines the column
                # into a single list
                lines.append(split_line[7].strip("\n"))
            except IndexError:
                # Get around the first line not being useful
                pass
        # Join all the elements into a single line
        fullstring = ''.join(lines)
        ''' Match the pattern to return only the useful portions.  Probably not the most optimal regex but there's a lot
        of variation in the output so it has to be a bit sloppy
        '''
    unmatched = re.search(search_regex, fullstring)
    try:
        return unmatched.group(1)
    except AttributeError:
        return False


def format_objdump(raw_string):
    '''
    The string is '.' delimited so replace that with '\n' and return it.
    '''
    # print (raw_string)
    return raw_string.replace(".", "\n")


def output_coredump(output, config):
    '''
    Outputs the coredump to either STDOUT or a file depending
    on options set at the CLI or in the config file
    '''
    filenum = 0
    for coredump in output:
        if config['output_method'] == 'stdout':
            # Print output to STDOUT
            print (coredump)
            filenum += 1
            print ("-" * 30 + " File " + str(filenum) + " " + "-" * 35 + "\n")
            print (output[coredump] + "\n")
        elif config['output_method'] == 'file':
            # Print to individual files
            if os.path.isdir(config['output_dir']):
                outputfile = os.path.join(
                    config['output_dir'], os.path.basename(coredump.replace('.tmp', '')))
                f = open(outputfile + config['suffix'], 'w')
                f.write(output[coredump])
                f.close()
            else:
                print (
                    "Error: \'" + config['output_dir'] + "\' is not a valid directory")
                sys.exit()


def cleanup(coredump):
    os.remove(coredump)

if __name__ == "__main__":
    args = parse_args()

    if not os.path.exists(args['config_file']):
        print ("Config  file " + args['config_file'] + " not found")
        sys.exit()
    else:
        config = parse_config(args['config_file'])

    '''
    Overwrite the config dict with the CLI args.  We should now have a dict
    that looks like this:

    {
        'search_regex': '([a-zA-Z0-9]+\\.[0-9]+\\.[0-9]+\\.DBPATH.*[a-zA-Z0-9]+)(\\.*$)', 
        'working_dir': './', 
        'output_method': 'file', 
        'suffix': '.man', 
        'output_dir': './'
    }

    '''
    config.update(args)
    output = {}
    coredumps = get_coredump_list(config['coredumps'])

    for filename in coredumps:
        '''
        For the list of files, run objdump command,
        build a list of files to process, format (split)
        them, and then add them format them and
        output them.  FInally, cleanup any temporary
        files
        '''
        print("Processing file {}...".format(filename))
        temp_file = run_objdump(filename, config)
        after_split = split_objdump(temp_file, config['search_regex'])
        if after_split is False:
            print ("File: \'" + filename +
                   "\' is likely not a properly formatted objdump.  Skipping...\n")
        else:
            output[temp_file] = (format_objdump(after_split))
            cleanup(temp_file)
output_coredump(output, config)